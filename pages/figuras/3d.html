<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Transforma√ß√µes 3D</title>
    <link rel="stylesheet" href="../../style.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
<h1>Transforma√ß√µes 3D</h1>

<nav>
    <a href="../../index.html" class="button">In√≠cio</a>
    <a href="2d.html" class="button">Ir para Transforma√ß√£o 2D</a>
    <button id="resetButton" class="button">Resetar Figura</button>
</nav>

<div class="main-container">
    <div id="ui-panel">
        <label>Transla√ß√£o X: <input type="range" id="tx" min="-5" max="5" step="0.1" value="0"></label>
        <label>Transla√ß√£o Y: <input type="range" id="ty" min="-5" max="5" step="0.1" value="0"></label>
        <div class="control-group">
            <label for="rot">Rota√ß√£o (¬∞):</label>
            <input type="range" id="rot" min="0" max="360" step="1" value="0"/>
        </div>
        <div class="control-group">
            <label for="scale">Escala:</label>
            <input type="range" id="scale" min="0.1" max="3" step="0.1" value="1"/>
        </div>
        <label>Cisalhamento XZ: <input type="range" id="shearXZ" min="-1" max="1" step="0.1" value="0"></label>
        <label>Cisalhamento YZ: <input type="range" id="shearYZ" min="-1" max="1" step="0.1" value="0"></label>
        <label>Cisalhamento ZX: <input type="range" id="shearZX" min="-1" max="1" step="0.1" value="0"></label>
    </div>
    <div class="display-area">
        <div id="canvas3D"></div>
    </div>
    <div id="formulas"></div>
</div>

<div style="max-width:800px; margin-top:30px; padding:10px; background:white; border:1px solid #ccc; border-radius:10px;">
    <h3>üß† Entendendo as Transforma√ß√µes 3D</h3>

    <p>O cubo que voc√™ v√™ na tela √© um objeto 3D renderizado usando a biblioteca <strong>Three.js</strong>. Atrav√©s de
        comandos JavaScript, conseguimos aplicar transforma√ß√µes geom√©tricas como <strong>transla√ß√£o</strong>, <strong>rota√ß√£o</strong>,
        <strong>escala</strong> e <strong>cisalhamento</strong> diretamente sobre ele, modificando sua matriz de
        transforma√ß√£o.</p>

    <h4>üîÑ Transla√ß√£o</h4>
    <p>
        A transla√ß√£o move o cubo no espa√ßo tridimensional sem alterar seu formato. No c√≥digo, usamos:
    </p>
    <pre><code>cube.applyMatrix4(new THREE.Matrix4().makeTranslation(tx, ty, 0));</code></pre>
    <p>
        Isso desloca o cubo no eixo X e Y com base nos valores dos controles deslizantes <code>tx</code> e
        <code>ty</code>. √â como empurrar um objeto pela mesa.
    </p>

    <h4>‚ü≥ Rota√ß√£o</h4>
    <p>
        A rota√ß√£o acontece ao redor do eixo Y (vertical). O √¢ngulo, em graus, √© convertido para radianos:
    </p>
    <pre><code>cube.applyMatrix4(new THREE.Matrix4().makeRotationY(rot * Math.PI / 180));</code></pre>
    <p>
        Isso gira o cubo lateralmente, como se ele estivesse se virando para olhar para outro lado.
    </p>

    <h4>üîç Escala</h4>
    <p>
        A escala altera proporcionalmente o tamanho do cubo nos tr√™s eixos (x, y e z):
    </p>
    <pre><code>cube.applyMatrix4(new THREE.Matrix4().makeScale(scale, scale, scale));</code></pre>
    <p>
        Voc√™ pode aumentar ou diminuir o cubo como se estivesse aplicando zoom tridimensional.
    </p>

    <h4>üìê Cisalhamento</h4>
    <p>
        O cisalhamento deforma o cubo, inclinando seus v√©rtices sem alterar seu volume original. Aqui usamos uma
        <strong>matriz customizada</strong> para cisalhamento entre os eixos:
    </p>
    <pre><code>
const shearMatrix = new THREE.Matrix4().set(
    1,        0, shearXZ, 0,
    0,        1, shearYZ, 0,
    shearZX,  0, 1,       0,
    0,        0, 0,       1
);
cube.applyMatrix4(shearMatrix);
    </code></pre>
    <p>
        Com isso, o cubo √© inclinado nos planos XZ, YZ e ZX. √â como empurrar um canto do cubo para deform√°-lo sem
        deslocar o centro.
    </p>

    <h4>üí° Dica T√©cnica</h4>
    <p>
        Quando o cubo sofre cisalhamento, a ilumina√ß√£o pode parecer "quebrada". Isso acontece porque as
        <strong>normais</strong> (que dizem √† luz como refletir nos objetos) ficam desatualizadas. Por isso usamos:
    </p>
    <pre><code>cube.geometry.computeVertexNormals();</code></pre>
    <p>
        Esse comando recalcula as normais, garantindo que as sombras se ajustem ao novo formato do cubo.
    </p>

    <h4>‚úÖ Conclus√£o</h4>
    <p>
        O mais interessante √© que todas essas transforma√ß√µes est√£o sendo aplicadas diretamente na matriz do cubo. Isso
        simula como gr√°ficos 3D funcionam em jogos, simula√ß√µes e engines profissionais. Aqui, voc√™ est√° literalmente
        controlando a matriz de transforma√ß√£o de um objeto 3D!
    </p>
</div>


<script src="../../js/transform3d.js"></script>
</body>
</html>
